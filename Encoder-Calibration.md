**Note: The new Dexter HDI shouldn't need calibration, and the re-calibration process is complex. _Don't calibrate a Dexter HDI!_**

When Dexter starts, it does not know where it is. And it does not have it's normal precision in detecting movements. The [encoders](Encoders) send signals back to the FPGA, but the FPGA doesn't know what those signals mean, because it hasn't seen the sequence of signals for each slot. Because of small variations in the printing of the slots, each slot is unique. Also, there are variations introduced by the positioning of the sensors with respect to the disk, drive level of the LEDs, etc... As a result, the signals recieved are different for each slot. 

So, before the encoders can work, each joint must be moved through it's entire range of motion and the signals for each slot recorded into the FPGAs memory. We call that "movement calibration" or "power on calibration" or "calibration" or just "cal" as opposed to "[eye calibration](Encoders#calibration)" (which is finding the center point of the sin/cos plot of the [encoders](Encoders) ). 

[Eye calibration](Encoders#unit-circle) must be completed before the calibration described here can be successful. HDI's are calibrated (both eye and movement) at the factory. _Don't calibrate a Dexter DHI!_

Power on calibration can be done in several ways:
- [DDE](DDE) has a "Calibrate Dexter..." dialog on the "Jobs" menu. There are 3 sections, first to select which robot to talk to, then a middle part for each joint to help adjust the "eye" pattern for each set of sensors and to mark the center. The last part, at the bottom, "3. Calibrate optical encoders", starts the calibration. This movement calibration is slow as it does each joint individually and it requires a lot of space, however, it is very smooth and provides the best results. **DO NOT SAVE CALIBRATION ON A DEXTER HDI** <BR>![Good encoder, after replacing Sensor in hole of encoder block.](https://user-images.githubusercontent.com/419392/59716213-6d9df300-91ca-11e9-87d6-0b530f39fb61.png)
- The file ["Cal.make_ins"](https://github.com/HaddingtonDynamics/Dexter/blob/master/Firmware/Cal.make_ins) can be run from the robot via the "S RunFile Cal.make_ins" [SetParameter](set-parameter-oplet) [oplet](Command-oplet-instruction). That file contains all the instructions required to move the joints through every position, just like step 2 in the DDE calibration dialog.
- The file ["FastCal.make_ins"](https://github.com/HaddingtonDynamics/Dexter/blob/master/Firmware/FastCal.make_ins) can be run from the robot via the "S RunFile FastCal.make_ins" [SetParameter](set-parameter-oplet) [oplet](Command-oplet-instruction). That file contains all the instructions required to move the joints through every position, all at the same time, and then turns on the necessary parts of the FPGA. It is very fast, and requires less space, but the shaking caused by moving all the joints at the same time can cause errors in the recording.
- Those same instructions (as sent from DDE or the make_ins files) can be sent from some other program. 

In any case, the data collected allows the FPGA to monitor joint position with extreme precision. It is important to understand that this relationship between where the joint motor was commanded to be, and the reading seen on the joint encoder, has no bearing on the actual slot in the encoder disk, or where that slot is. In fact, the slots can be imperfect in many ways and those errors are effectively removed by this mapping.

Actually, all that data is recorded, in a file called HiMem.dta, and that file is loaded back into RAM on startup. The problem is, there is no way to match the current position of a joint with a position in the data file. If the arm is calibrated, and the file saved, then turned off, and the arm is moved, then turned back on again, the position is unknown. 

Not knowing where the arm is when it powers up would seem to be [a simple problem to solve](https://github.com/HaddingtonDynamics/Dexter/issues/5), but it is not. Limit switches require another set of wires to each joint, and extra wires are amazingly difficult to run. It is possible to create an index pulse of sorts on the encoder disk by partly filling in one slot; not enough to affect operation, but still detectable. Another possibility is to always start the arm in the same position, and that is the approach we have most often used. Small knob / arrows on each motor shaft can be aligned to a know position and that gets us close enough to then find our place in a slot. 

Even better, with a "garage" or "dock" where the tool interface is placed before powerup, we can know where the arm is on power up. Then we can set the position into the data from the HiMem.dta file, and know exactly where we are. Some changes required to make this possible were made in the [2018/12/10 released](https://github.com/HaddingtonDynamics/Dexter/commit/50257ea7178e0d76e99f8571c61051b56fff7421) (off the Master branch)
